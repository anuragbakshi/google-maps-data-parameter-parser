{"version":3,"sources":["../src/gmdp.ts","../src/basic-node.ts","../src/prbufnode.ts","../src/gmdp-point.ts","../src/gmdp-waypoint.ts","../src/gmdp-route.ts","../src/gmdp-exception.ts"],"sourcesContent":["import { PrBufNode } from \"./prbufnode\";\nimport { GmdpPoint } from \"./gmdp-point\";\nimport { GmdpWaypoint } from \"./gmdp-waypoint\";\nimport { GmdpRoute } from \"./gmdp-route\";\n\nimport { GmdpException } from \"./gmdp-exception\";\n\n/**\n * Represents a google maps data parameter, constructed from the passed URL.\n *\n * Utility methods defined below allow the user to easily extract interesting\n * information from the data parameter.\n */\nexport class Gmdp {\n    prBufRoot: PrBufNode | null;\n    mapType: \"map\" | \"streetview\" | \"earth\" | \"photosphere\";\n    pins: GmdpPoint[] = [];\n    route?: GmdpRoute;\n    oldRoute?: GmdpRoute;\n    svURL?: string;\n    localSearchMap?: { centre: GmdpPoint; resolution: string };\n\n    constructor(url: string) {\n        let localSearchMapChildren;\n        let child;\n        this.prBufRoot = PrBufNode.create(url);\n        this.mapType = \"map\";\n\n        if (this.prBufRoot == null) {\n            throw new GmdpException(\"no parsable data parameter found\");\n        }\n\n        //the main top node for routes is 4m; other urls (eg. streetview) feature 3m etc.\n        let routeTop = null;\n        let streetviewTop = null;\n\n        for (child of this.prBufRoot.getChildren()) {\n            if (child.id() === 1 && child.type() === \"m\") {\n                localSearchMapChildren = child.getChildren();\n            } else if (child.id() === 3 && child.type() === \"m\") {\n                let mapTypeChildren = child.getChildren();\n                if (mapTypeChildren && mapTypeChildren.length >= 1) {\n                    if (\n                        mapTypeChildren[0].id() === 1 &&\n                        mapTypeChildren[0].type() === \"e\"\n                    ) {\n                        switch (mapTypeChildren[0].value()) {\n                            case \"1\":\n                                this.mapType = \"streetview\";\n                                streetviewTop = child;\n                                break;\n                            case \"3\":\n                                this.mapType = \"earth\";\n                                break;\n                        }\n                    }\n                }\n            } else if (child.id() === 4 && child.type() === \"m\") {\n                routeTop = child;\n            }\n        }\n        let pinData = null;\n        let directions = null;\n        let oldDirections = null;\n        if (routeTop) {\n            for (child of routeTop.getChildren()) {\n                if (child.id() === 3 && child.type() === \"m\") {\n                    pinData = child;\n                } else if (child.id() === 4 && child.type() === \"m\") {\n                    directions = child;\n                } else if (child.id() === 1 && child.type() === \"m\") {\n                    //1m_ indicates the old route, pin, or search location\n                    //it seems that there can't be both a current route and an old route, for example\n                    //so we can treat its children as regular pins or directions\n                    for (let grandchild of child.getChildren()) {\n                        if (\n                            grandchild.id() === 3 &&\n                            grandchild.type() === \"m\"\n                        ) {\n                            if (!pinData) {\n                                pinData = grandchild;\n                            }\n                        } else if (\n                            grandchild.id() === 4 &&\n                            grandchild.type() === \"m\"\n                        ) {\n                            if (!directions) {\n                                oldDirections = grandchild;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (pinData) {\n            let pinPoint = this.parsePin(pinData);\n            if (pinPoint) {\n                this.pushPin(pinPoint);\n            }\n        }\n        if (directions) {\n            this.route = this.parseRoute(directions);\n        } else if (oldDirections) {\n            this.oldRoute = this.parseRoute(oldDirections);\n        }\n        if (streetviewTop) {\n            let streetviewChildren = streetviewTop.getChildren();\n            for (let streetviewChild of streetviewChildren) {\n                if (\n                    streetviewChild.id() === 3 &&\n                    streetviewChild.type() === \"m\"\n                ) {\n                    let svInfos = streetviewChild.getChildren();\n                    for (let svInfo of svInfos) {\n                        if (svInfo.id() === 2 && svInfo.type() === \"e\") {\n                            if (svInfo.value() === \"4\") {\n                                //!2e4!3e11 indicates a photosphere, rather than standard streetview\n                                //but the 3e11 doesn't seem to matter too much (?)\n                                this.mapType = \"photosphere\";\n                            }\n                        }\n                        if (svInfo.id() === 6 && svInfo.type() === \"s\") {\n                            this.svURL = decodeURIComponent(svInfo.value());\n                        }\n                    }\n                }\n            }\n        }\n        if (localSearchMapChildren && localSearchMapChildren.length >= 1) {\n            let lsmLat = undefined;\n            let lsmLng = undefined;\n            let lsmResolution = undefined;\n            for (let field of localSearchMapChildren) {\n                if (field.type() === \"d\") {\n                    switch (field.id()) {\n                        case 1:\n                            lsmResolution = field.value();\n                            break;\n                        case 2:\n                            lsmLng = field.value();\n                            break;\n                        case 3:\n                            lsmLat = field.value();\n                            break;\n                    }\n                }\n            }\n            if (\n                lsmLat !== undefined &&\n                lsmLng !== undefined &&\n                lsmResolution !== undefined\n            ) {\n                this.localSearchMap = {\n                    centre: new GmdpPoint(lsmLat, lsmLng),\n                    resolution: lsmResolution,\n                };\n            }\n        }\n    }\n\n    parsePin(pinNode: PrBufNode) {\n        let pinPoint = null;\n        for (let primaryChild of pinNode.getChildren()) {\n            if (primaryChild.id() === 8 && primaryChild.type() === \"m\") {\n                const coordNodes = primaryChild.getChildren();\n                if (\n                    coordNodes &&\n                    coordNodes.length >= 2 &&\n                    coordNodes[0].id() === 3 &&\n                    coordNodes[0].type() === \"d\" &&\n                    coordNodes[1].id() === 4 &&\n                    coordNodes[1].type() === \"d\"\n                ) {\n                    pinPoint = new GmdpPoint(\n                        coordNodes[0].value(),\n                        coordNodes[1].value()\n                    );\n                }\n            }\n        }\n        return pinPoint;\n    }\n\n    parseRoute(directionsNode: PrBufNode) {\n        const route = new GmdpRoute();\n        route.arrDepTimeType = \"leave now\"; //default if no value is specified\n        route.avoidHighways = false;\n        route.avoidTolls = false;\n        route.avoidFerries = false;\n        route.transitModePref = [];\n\n        for (let primaryChild of directionsNode.getChildren()) {\n            if (primaryChild.id() === 1 && primaryChild.type() === \"m\") {\n                if (primaryChild.value() === \"0\") {\n                    route.pushWaypoint(\n                        new GmdpWaypoint(undefined, undefined, true)\n                    );\n                } else {\n                    let addedPrimaryWpt = false;\n                    const wptNodes = primaryChild.getChildren();\n                    for (let wptNode of wptNodes) {\n                        if (wptNode.id() === 2) {\n                            //this is the primary wpt, add coords\n                            const coordNodes = wptNode.getChildren();\n                            if (\n                                coordNodes &&\n                                coordNodes.length >= 2 &&\n                                coordNodes[0].id() === 1 &&\n                                coordNodes[0].type() === \"d\" &&\n                                coordNodes[1].id() === 2 &&\n                                coordNodes[1].type() === \"d\"\n                            ) {\n                                route.pushWaypoint(\n                                    new GmdpWaypoint(\n                                        coordNodes[1].value(),\n                                        coordNodes[0].value(),\n                                        true\n                                    )\n                                );\n                            }\n                            addedPrimaryWpt = true;\n                        } else if (wptNode.id() === 3) {\n                            //this is a secondary (unnamed) wpt\n                            //\n                            //but first, if we haven't yet added the primary wpt,\n                            //then the coordinates are apparently not specified,\n                            //so we should add an empty wpt\n                            if (!addedPrimaryWpt) {\n                                route.pushWaypoint(\n                                    new GmdpWaypoint(undefined, undefined, true)\n                                );\n                                addedPrimaryWpt = true;\n                            }\n\n                            //now proceed with the secondary wpt itself\n                            const secondaryWpts = wptNode.getChildren();\n                            if (secondaryWpts && secondaryWpts.length > 1) {\n                                const coordNodes =\n                                    secondaryWpts[0].getChildren();\n                                if (\n                                    coordNodes &&\n                                    coordNodes.length >= 2 &&\n                                    coordNodes[0].id() === 1 &&\n                                    coordNodes[0].type() === \"d\" &&\n                                    coordNodes[1].id() === 2 &&\n                                    coordNodes[1].type() === \"d\"\n                                ) {\n                                    route.pushWaypoint(\n                                        new GmdpWaypoint(\n                                            coordNodes[1].value(),\n                                            coordNodes[0].value(),\n                                            false\n                                        )\n                                    );\n                                }\n                            }\n                        } else if (\n                            wptNode.id() === 4 &&\n                            wptNode.type() === \"e\"\n                        ) {\n                            route.pushWaypoint(\n                                new GmdpWaypoint(undefined, undefined, true)\n                            );\n                            addedPrimaryWpt = true;\n                        }\n                    }\n                }\n            } else if (primaryChild.id() === 2 && primaryChild.type() === \"m\") {\n                const routeOptions = primaryChild.getChildren();\n                for (let routeOption of routeOptions) {\n                    if (routeOption.id() === 1 && routeOption.type() === \"b\") {\n                        route.avoidHighways = true;\n                    } else if (\n                        routeOption.id() === 2 &&\n                        routeOption.type() === \"b\"\n                    ) {\n                        route.avoidTolls = true;\n                    } else if (\n                        routeOption.id() === 3 &&\n                        routeOption.type() === \"b\"\n                    ) {\n                        route.avoidFerries = true;\n                    } else if (\n                        routeOption.id() === 4 &&\n                        routeOption.type() === \"e\"\n                    ) {\n                        route.setRoutePref(routeOption.value());\n                    } else if (\n                        routeOption.id() === 5 &&\n                        routeOption.type() === \"e\"\n                    ) {\n                        route.addTransitModePref(routeOption.value());\n                    } else if (\n                        routeOption.id() === 6 &&\n                        routeOption.type() === \"e\"\n                    ) {\n                        route.setArrDepTimeType(routeOption.value());\n                    }\n                    if (routeOption.id() === 8 && routeOption.type() === \"j\") {\n                        route.arrDepTime = Number(routeOption.value()); //as a unix timestamp\n                    }\n                }\n            } else if (primaryChild.id() === 3 && primaryChild.type() === \"e\") {\n                route.setTransportation(primaryChild.value());\n            } else if (primaryChild.id() === 4 && primaryChild.type() === \"e\") {\n                route.setUnit(primaryChild.value());\n            }\n        }\n\n        return route;\n    }\n\n    pushPin(wpt: GmdpPoint) {\n        if (wpt instanceof GmdpPoint) {\n            this.pins.push(wpt);\n        }\n    }\n\n    /**\n     * Returns the route defined by this data parameter.\n     * @returns {GmdpRoute}\n     */\n    getRoute() {\n        return this.route;\n    }\n\n    /**\n     * Returns the route defined by this data parameter.\n     */\n    getOldRoute() {\n        return this.oldRoute;\n    }\n\n    /**\n     * Returns the main map type (\"map\", \"earth\").\n     */\n    getMapType() {\n        return this.mapType;\n    }\n\n    /**\n     * Returns the main map type (\"map\", \"earth\").\n     */\n    getStreetviewURL() {\n        return this.svURL;\n    }\n\n    /**\n     * Returns the pinned location.\n     */\n    getPins() {\n        return this.pins;\n    }\n\n    /**\n     * Returns local search map data.\n     */\n    getLocalSearchMap() {\n        return this.localSearchMap;\n    }\n}\n\nexport { GmdpPoint } from \"./gmdp-point\";\nexport { GmdpWaypoint } from \"./gmdp-waypoint\";\nexport { GmdpRoute } from \"./gmdp-route\";\n","export class BasicNode<T> {\n    children: this[] = [];\n    parent?: this;\n\n    constructor(public val: T) {}\n\n    /**\n     * Sets the parent node of this node.\n     */\n    setParentNode(node: this) {\n        this.parent = node;\n        node.children[node.children.length] = this;\n    }\n\n    /**\n     * Gets the parent node of this node.\n     */\n    getParentNode() {\n        return this.parent;\n    }\n\n    /**\n     * Adds a child node of this node.\n     */\n    addChild(node: this) {\n        node.parent = this;\n        this.children[this.children.length] = node;\n    }\n\n    /**\n     * Gets the array of child nodes of this node.\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     * Removes all the children of this node.\n     */\n    removeChildren() {\n        for (let child of this.children) {\n            delete child.parent;\n        }\n\n        this.children = [];\n    }\n\n    /**\n     * Recursively counts the number of all descendants, from children down, and\n     * returns the total number.\n     */\n    getTotalDescendantCount() {\n        let count = 0;\n        for (let child of this.children) {\n            count += child.getTotalDescendantCount();\n        }\n\n        return count + this.children.length;\n    }\n}\n","import { BasicNode } from \"./basic-node\";\n\n/**\n * Protocol Buffer implementation, which extends the functionality of Node\n * while specifically typing the stored value\n */\nexport class PrBufNode extends BasicNode<{\n    id: number;\n    type: string;\n    value: string;\n}> {\n    constructor(id: number, type: string, value: string) {\n        super({ id, type, value });\n    }\n\n    id() {\n        return this.val.id;\n    }\n\n    type() {\n        return this.val.type;\n    }\n\n    value() {\n        return this.val.value;\n    }\n\n    /**\n     * Compares the number of descendants with the value specified in the map element.\n     * If all the children have not yet been added, we continue adding to this element.\n     */\n    findLatestIncompleteNode(): this {\n        //if it's a branch (map) node ('m') and has room,\n        //or if it's the root (identified by having a null parent), which has no element limit,\n        //then return this node\n        if (\n            (this.val.type === \"m\" &&\n                Number(this.val.value) > this.getTotalDescendantCount()) ||\n            undefined === this.parent\n        ) {\n            return this;\n        } else {\n            return this.parent.findLatestIncompleteNode();\n        }\n    }\n    /**\n     * Parses the input URL 'data' protocol buffer parameter into a tree\n     */\n    static create(urlToParse: string): PrBufNode | null {\n        let rootNode = null;\n        let re = /data=!([^?&]+)/;\n        let dataArray = urlToParse.match(re);\n        if (!dataArray || dataArray.length < 1) {\n            re = /mv:!([^?&]+)/;\n            dataArray = urlToParse.match(re);\n        }\n        if (dataArray && dataArray.length >= 1) {\n            rootNode = new PrBufNode(0, \"root\", \"root\");\n            let workingNode = rootNode;\n            //we iterate through each of the elements, creating a node for it, and\n            //deciding where to place it in the tree\n            let elemArray = dataArray[1].split(\"!\");\n            for (let i = 0; i < elemArray.length; i++) {\n                const elemRe = /^([0-9]+)([a-z])(.+)$/;\n                const elemValsArray = elemArray[i].match(elemRe);\n                if (elemValsArray && elemValsArray.length > 3) {\n                    const elemNode = new PrBufNode(\n                        parseInt(elemValsArray[1]),\n                        elemValsArray[2],\n                        elemValsArray[3]\n                    );\n                    workingNode.addChild(elemNode);\n                    workingNode = elemNode.findLatestIncompleteNode();\n                }\n            }\n        }\n        return rootNode;\n    }\n}\n","export class GmdpPoint {\n    lat: number;\n    lng: number;\n\n    constructor(lat: number | string, lng: number | string) {\n        this.lat = Number(lat);\n        this.lng = Number(lng);\n    }\n}\n","/**\n * Represents a basic waypoint, with latitude and longitude.\n *\n * If both are not specified, the waypoint is considered to be valid\n * but empty waypoint (these can exist in the data parameter, where\n * the coordinates have been specified in the URL path.\n */\nexport class GmdpWaypoint {\n    lat?: number;\n    lng?: number;\n\n    constructor(\n        lat: number | string | undefined,\n        lng: number | string | undefined,\n        public primary: boolean\n    ) {\n        if (lat !== undefined) {\n            this.lat = Number(lat);\n        }\n\n        if (lng !== undefined) {\n            this.lng = Number(lng);\n        }\n    }\n}\n","import { GmdpWaypoint } from \"./gmdp-waypoint\";\n/**\n * Represents a basic route, comprised of an ordered list of\n * GmdpWaypoint objects.\n */\nexport class GmdpRoute {\n    route: GmdpWaypoint[] = [];\n    transportation?:\n        | \"DRIVE\"\n        | \"TRANSIT\"\n        | \"BICYCLE\"\n        | \"WALK\"\n        | \"FLY\"\n        | { other: string };\n    unit?: \"METRIC\" | \"IMPERIAL\";\n\n    arrDepTimeType?: \"depart at\" | \"arrive by\" | \"last available\" | \"leave now\";\n    arrDepTime?: number;\n\n    routePref?: \"best route\" | \"fewer transfers\" | \"less walking\";\n    transitModePref: (\"bus\" | \"subway\" | \"train\" | \"tram / light rail\")[] = [];\n\n    avoidHighways = false;\n    avoidTolls = false;\n    avoidFerries = false;\n\n    constructor() {}\n\n    /**\n     * Pushes a GmdpWaypoint on to the end of this GmdpRoute.\n     */\n    pushWaypoint(wpt: GmdpWaypoint) {\n        if (wpt instanceof GmdpWaypoint) {\n            this.route.push(wpt);\n        }\n    }\n\n    /**\n     * Sets the mode of transportation.\n     * If the passed parameter represents one of the integers normally used by Google Maps,\n     * it will be interpreted as the relevant transport mode, and set as a string:\n     * \"car\", \"bike\", \"foot\", \"transit\", \"flight\"\n     */\n    setTransportation(transportation: string) {\n        switch (transportation) {\n            case \"0\":\n                this.transportation = \"DRIVE\";\n                break;\n            case \"1\":\n                this.transportation = \"BICYCLE\";\n                break;\n            case \"2\":\n                this.transportation = \"WALK\";\n                break;\n            case \"3\":\n                this.transportation = \"TRANSIT\";\n                break;\n            case \"4\":\n                this.transportation = \"FLY\";\n                break;\n            default:\n                this.transportation = { other: transportation };\n                break;\n        }\n    }\n\n    /**\n     * Returns the mode of transportation (if any) for the route.\n     */\n    getTransportation() {\n        return this.transportation;\n    }\n\n    setUnit(unit: string) {\n        switch (unit) {\n            case \"0\":\n                this.unit = \"METRIC\";\n                break;\n            case \"1\":\n                this.unit = \"IMPERIAL\";\n                break;\n        }\n    }\n\n    getUnit() {\n        return this.unit;\n    }\n\n    setRoutePref(routePref: string) {\n        switch (routePref) {\n            case \"0\":\n            case \"1\":\n                this.routePref = \"best route\";\n                break;\n            case \"2\":\n                this.routePref = \"fewer transfers\";\n                break;\n            case \"3\":\n                this.routePref = \"less walking\";\n                break;\n        }\n    }\n\n    getRoutePref() {\n        return this.routePref;\n    }\n\n    setArrDepTimeType(arrDepTimeType: string) {\n        switch (arrDepTimeType) {\n            case \"0\":\n                this.arrDepTimeType = \"depart at\";\n                break;\n            case \"1\":\n                this.arrDepTimeType = \"arrive by\";\n                break;\n            case \"2\":\n                this.arrDepTimeType = \"last available\";\n                break;\n        }\n    }\n\n    getArrDepTimeType() {\n        return this.arrDepTimeType;\n    }\n\n    addTransitModePref(transitModePref: string) {\n        //there can be multiple preferred transit modes, so we store them in an array\n        //we assume there will be no duplicate values, but it probably doesn't matter\n        //even if there are\n        switch (transitModePref) {\n            case \"0\":\n                this.transitModePref.push(\"bus\");\n                break;\n            case \"1\":\n                this.transitModePref.push(\"subway\");\n                break;\n            case \"2\":\n                this.transitModePref.push(\"train\");\n                break;\n            case \"3\":\n                this.transitModePref.push(\"tram / light rail\");\n                break;\n        }\n    }\n\n    /**\n     *\n     * @returns {string[]}\n     */\n    getTransitModePref() {\n        return this.transitModePref;\n    }\n\n    /**\n     * Returns the list of all waypoints belonging to this route.\n     * @returns {GmdpWaypoint[]}\n     */\n    getAllWaypoints() {\n        return this.route;\n    }\n}\n","export class GmdpException extends Error {\n    name = \"GmdpException\";\n\n    constructor(message: string) {\n        super(message);\n\n        // Use V8's native method if available, otherwise fallback\n        if (\"captureStackTrace\" in Error) {\n            Error.captureStackTrace(this, GmdpException);\n        }\n    }\n}\n"],"mappings":"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","names":[]}